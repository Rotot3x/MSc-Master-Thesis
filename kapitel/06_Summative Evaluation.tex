\newpage
\section{Summative Evaluation} \label{sec:Summative Evaluation}

Die summative Evaluation validiert das finale Artefakt gegen die in Kapitel~\ref{sec:FEDS-Framework} definierten Evaluationsziele sowie die funktionalen und Compliance-Anforderungen aus Kapitel~\ref{sec:Anforderungsanalyse}. Im Gegensatz zu den formativen Evaluationsepisoden (Kapitel~\ref{sec:formative_evaluation_iteration1} und Kapitel~\ref{sec:formative_evaluation_iteration2}), die modulare Einzelkomponenten prüften, erfolgt die summative Evaluation als systematische Requirement-Tracing am integrierten Gesamtsystem. Das Ziel besteht im rigorosen Nachweis der Efficacy und Fidelity, um die technische Machbarkeit und regulatorische Konformität des \ac{PQC}-basierten \ac{SSI}-Prototypen für \ac{KRITIS} zu demonstrieren.

Die Evaluierung wird anhand eines domänenrealistischen \ac{KRITIS}-Szenarios durchgeführt (\ref{sec:Anhang_KRITIS Szenario}), das einen Notfall-Wartungszertifizierungsprozess in einem Stromversorgungsnetz abbildet und alle sechs funktionalen Anforderungen integriert. Die detaillierte technische Dokumentation ist in \ref{sec:Anhang_Summative Evaluation} aufgeführt und referenziert Jupyter-Notebook-Cells (Listing~A-\ref{lst:Jupyter-Notebook-Cell-1} bis Listing~A-\ref{lst:Jupyter-Notebook-Cell-23-output}).

Bevor die eigentliche Validierung der funktionalen Anforderungen beginnt, ist zunächst die Initialisierung des Artefakts erforderlich. Das technische Setup deklariert zentrale Variablen, Basis-URLs der Admin-APIs sowie Hilfsfunktionen zur HTTP-Kommunikation (Listing~A-\ref{lst:Jupyter-Notebook-Cell-1}). Auf dieser Grundlage wird die Infrastruktur überprüft und die erfolgreiche Ledger-Initialisierung durch Abruf der Genesis-Transaktionen und Validator-Node-Registrierungen nachgewiesen, womit alle benötigten Kernkomponenten (Indy-Ledger, Validator-Nodes, Tails-Server) in konsistentem Zustand vorliegen (Listing~A-\ref{lst:Jupyter-Notebook-Cell-2-output}).

Die domänenrelevante Identitätsinfrastruktur für den KRITIS-Issuer wird vorbereitet durch lokale Erzeugung einer neuen Indy-DID als kryptographische Identität des Energienetzbetreibers (Listing~A-\ref{lst:Jupyter-Notebook-Cell-3-output}). Diese DID wird via NYM-Transaktion als ENDORSER auf dem Ledger registriert, womit der Issuer als vertrauenswürdiger Teilnehmer verankert wird (Listing~A-\ref{lst:Jupyter-Notebook-Cell-4-output}). Die Wallet-Ansicht bestätigt das Ed25519-Schlüsselmaterial und Status \enquote{posted=true}, womit die On-Ledger-Publikation nachgewiesen wird (Listing~A-\ref{lst:Jupyter-Notebook-Cell-5-output}).

Die fachlichen Grundlagen für die Zertifikatsausstellung werden geschaffen durch ein spezifisches Schema für das KRITIS-Notfall-Wartungszertifikat mit neun Attributen (Listing~A-\ref{lst:Jupyter-Notebook-Cell-6-output}). Eine Issuer-spezifische Credential Definition mit zugehöriger Revocation Registry wird erzeugt, die kryptographische Parameter und Revokationsmechanismen festlegt (Listing~A-\ref{lst:Jupyter-Notebook-Cell-7-output}). Mit Abschluss dieser Initialisierungsschritte liegt ein vollständig instanziiertes Artefakt auf reproduzierbarem, domänenkonsistentem Fundament vor.

\subsection{Validierung der funktionalen Anforderungen}
\label{sec:Validierung der funktionalen Anforderungen}

\subsubsection{Issuer Discovery}

Die funktionale Anforderung FR1 fordert, dass das System die Auffindbarkeit von publizierten Credential-Schemata des Issuers digitaler Identitätsnachweise ermöglichen muss. Die Erfüllung dieser Anforderung an das finale Artefakt wird anhand eines dreiphasigen, Ledger-basierten Discovery-Mechanismus demonstriert (Listing~A-\ref{lst:Jupyter-Notebook-Cell-8} und Listing~A-\ref{lst:Jupyter-Notebook-Cell-8-output}). 

Phase 1 extrahiert alle TRUST\_ANCHOR-Identitäten (Role '101') aus NYM-Transaktionen des Domain Ledgers, wobei im KRITIS-Szenario der Issuer \enquote{Energienetzbetreiber} mit DID \enquote{9pbXiFBZZGwXKp61HQBz3J} identifiziert wird (Listing~A-\ref{lst:Jupyter-Notebook-Cell-8-output}). 

Phase 2 verifiziert sechs kryptographische Eigenschaften (DID-Identifier, Ed25519-Verkey, TRUST\_ANCHOR-Role, Endorser, On-Ledger-Aktivitäten, Registrierungszeitpunkt) mittels der Funktion verify\_issuer\_identity(), wobei für den identifizierten Issuer alle Eigenschaften erfolgreich validiert werden (Listing~A-\ref{lst:Jupyter-Notebook-Cell-8-output}). 

Phase 3 filtert SCHEMA-Transaktionen nach dem Schema-Namen \enquote{kritis\_emergency\_maintenance\_cert}, extrahiert den Issuer-DID aus dem Schema-Identifier-Format \enquote{<issuer\_did>:2:<schema\_name>:<version>} und führt eine Cross-Referenzierung mit den TRUST\_ANCHOR-Identitäten durch (Listing~A-\ref{lst:Jupyter-Notebook-Cell-8-output}).


\subsubsection{Connection Creation}

Die funktionale Anforderung FR2 verlangt die Etablierung von Verbindungen zwischen SSI-Akteuren. Dies wird mittels eines dreiphasigen Out-of-Band-Protokoll-Workflows mit did:peer:4-basierter \ac{PQC} demonstriert.

Phase~1 implementiert einen Pre-Check existierender Connections via \enquote{GET /connections} auf beiden Agenten, um redundante Connection-Erstellungen zu vermeiden. Im KRITIS-Szenario werden keine existierenden Connections gefunden, wodurch eine neue Etablierung ausgelöst wird (Listing~A-\ref{lst:Jupyter-Notebook-Cell-9-output}).

Phase~2 realisiert die Connection-Etablierung mittels Aries RFC~0434 Out-of-Band Protocol \parencite{decentralized-identity_AriesrfcsFeatures0434outofbandREADMEmdmaindecentralizedidentityariesrfcs_}. Der Inviter erstellt eine Invitation mit \enquote{use\_did\_method: 'did:peer:4'} und erhält eine invitation\_msg\_id als eindeutigen Identifier (Listing~A-\ref{lst:Jupyter-Notebook-Cell-9-output}). Der Invitee akzeptiert die Invitation, wodurch das DIDExchange-Protokoll did:peer:4-DIDs mit ML-DSA-65- sowie ML-KEM-768-Schlüsselmaterial generiert (Listing~A-\ref{lst:Jupyter-Notebook-Cell-10-output} und Listing~A-\ref{lst:Jupyter-Notebook-Cell-12-output}). Die resultierenden DID-Metadaten bestätigen \enquote{pqc\_enabled: true}, \enquote{signature\_algorithm: ml-dsa-65} und \enquote{key\_agreement\_algorithm: ml-kem-768}.

Phase~3 validiert die Connection-Konsistenz durch Vergleich der invitation\_msg\_id, komplementärer their\_role-Werte (inviter/invitee) und beidseitigen State active (Listing~A-\ref{lst:Jupyter-Notebook-Cell-9-output}). Die Connection-Übersicht (Listing~A-\ref{lst:Jupyter-Notebook-Cell-11-output}) zeigt zwei aktive Connection-Paare (Issuer\,$\leftrightarrow$\,Holder und Holder\,$\leftrightarrow$\,Verifier), womit die vollständige Konnektivität des \ac{SSI}-Dreiecks nachgewiesen wird.

\subsubsection{Credential Creation}

Die funktionale Anforderung FR3 fordert, dass das System Funktionalität zur Erstellung und Ausstellung digitaler Credentials bereitstellen muss. Die Erfüllung wird anhand eines mehrstufigen Credential-Issuance-Workflows mit Revocation-Registry-Integration demonstriert.

Der Issuer initiiert die Credential-Ausstellung durch Versenden eines Credential Offers mit einer Credential Preview, welche neun KRITIS-spezifische Attribute enthält. Die Ausstellung erfolgt dabei über die in FR2 etablierte connection\_id und die in FR1 identifizierte cred\_def\_id (Listing~A-\ref{lst:Jupyter-Notebook-Cell-13-output}). Der Holder akzeptiert das Offer automatisch, wodurch das Aries RFC~0453 Issue Credential v2.0 Protocol \parencite{decentralized-identity_AriesrfcsFeatures0453issuecredentialv2maindecentralizedidentityariesrfcsGitHub_} den vollständigen State-Machine-Durchlauf (offer-sent --> request-sent --> credential-issued --> done) ausführt und das Credential im Holder Wallet persistiert (Listing~A-\ref{lst:Jupyter-Notebook-Cell-13-output}).

Die Revocation-Registry-Integration extrahiert zwei kritische Identifier aus der Issuer-Exchange-Response. Die Revocation Registry ID identifiziert die auf dem Indy Ledger publizierte Revocation Registry (Type~113), während die Credential Revocation ID \enquote{1} die Position im Revocation-Accumulator spezifiziert (Listing~A-\ref{lst:Jupyter-Notebook-Cell-13-output}). Die Holder-Credentials-Übersicht (Listing~A-\ref{lst:Jupyter-Notebook-Cell-14-output}) zeigt das vollständig ausgestellte KRITIS-Notfall-Wartungszertifikat mit allen Attributen, dem Schema-Identifier aus FR1 und dem initialen Revoked-Status false, womit die Gültigkeit bestätigt wird.

\subsubsection{Verification with Credentials}

Die funktionale Anforderung FR4 fordert, dass das System einen Verifikationsprozess zwischen Identity Holder, Verifier und blockchain-basierter \ac{VDR} durch Validierung eines Identitätsnachweises ermöglichen muss. Die Erfüllung wird anhand eines vierstufigen Privacy-Preserving-Verification-Workflows mit \ac{ZKP}, Revocation-Detection und Zeitgültigkeitsprüfung demonstriert.

Der Verifier initiiert den Verifikationsprozess durch Versenden eines Proof Requests mit einer Indy-Proof-Request-Struktur, die fünf offengelegte Attribute (cert\_type, facility\_type, epoch\_valid\_from, epoch\_valid\_until, role) und ein Zero-Knowledge-Predicate (security\_clearance\_level >= 2) fordert, während drei Identitätsattribute (first\_name, name, organisation) durch Selective Disclosure geschützt bleiben (Listing~A-\ref{lst:Jupyter-Notebook-Cell-15} und A-\ref{lst:Jupyter-Notebook-Cell-15-Output}). Alle Attribute enthalten eine non\_revoked-Constraint mit Zeitintervall, die eine Ledger-basierte Echtzeit-Revocation-Prüfung gegen die Revocation Registry erzwingt.

Der Holder empfängt den Proof Request und prüft verfügbare Credentials für die Präsentation (Listing~A-\ref{lst:Jupyter-Notebook-Cell-16} und A-\ref{lst:Jupyter-Notebook-Cell-16-Output}). Anschließend konstruiert er ein requested\_credentials-Objekt durch Mapping der fünf Attribute-Referents und des Predicate-Referents auf die Credential-ID, wobei Attribute mit \enquote{revealed: true} gekennzeichnet werden. Der Versand der Presentation erzeugt einen Zero-Knowledge-Proof, der kryptographisch beweist, dass der Holder ein Credential mit den geforderten Attributen besitzt, ohne die unrevealed Attribute offenzulegen (Listing~A-\ref{lst:Jupyter-Notebook-Cell-17} und A-\ref{lst:Jupyter-Notebook-Cell-17-Output}).

Der Verifier empfängt die Presentation (State done, verified: true) und extrahiert die revealed Attributes durch dreistufiges Mapping, wodurch fünf offengelegte Attribute extrahiert werden (Listing~A-\ref{lst:Jupyter-Notebook-Cell-18-Output}). Die drei Identitätsattribute bleiben geschützt und werden als \enquote{NICHT offengelegt (Zero-Knowledge-Proof)} ausgewiesen, wodurch Privacy by Design gemäß \ac{DSGVO} Art.~25 realisiert wird. Die Blockchain-basierte Revocation-Prüfung validiert den Credential-Status durch Vergleich des Indy-Proof-Timestamps mit dem Revocation-Registry-Delta auf dem Ledger. Die Zeitgültigkeitsprüfung vergleicht einen aktuellen Epoch-Timestamp mit den extrahierten Zeitgrenzen, wobei die Bedingung epoch\_valid\_from <= current\_epoch <= epoch\_valid\_until die zeitliche Gültigkeit bestätigt. Die finale Zugriffsentscheidung kombiniert drei Validierungsergebnisse (not is\_revoked AND is\_time\_valid AND has\_required\_clearance) und führt im KRITIS-Szenario zum Ergebnis \enquote{ZUGANG GEWÄHRT}.

\subsubsection{Credential Revocation}

Die funktionale Anforderung FR5 fordert, dass das System die Ungültigkeitserklärung ausgestellter Credentials mit kryptographischer Verifikation durch Verifier ermöglichen muss. Die Erfüllung wird anhand eines dreiphasigen Revocation-Workflows demonstriert, welcher Registry-Management, Two-Phase-Revocation sowie Non-Revocation-Proof Verification umfasst.

Phase~1 implementiert die Revocation-Registry-Verwaltung durch den Issuer. Der Abruf aktiver Registries (Listing~A-\ref{lst:Jupyter-Notebook-Cell-19-output}) zeigt zwei Registries mit 100 Credential-Kapazität. Jede Registry enthält die Metadaten rev\_reg\_id (eindeutiger Identifier), tails\_hash (kryptographischer Hash für Non-Revocation-Proofs) und tails\_local\_path (Speicherort der Tails-File für Accumulator-basierte Revocation nach CL-Signature-Schema).

Phase~2 realisiert die Two-Phase-Revocation durch Staging und Ledger-Publishing. Die Staging-Phase (Listing~A-\ref{lst:Jupyter-Notebook-Cell-20-output}) referenziert das Credential via rev\_reg\_id und cred\_rev\_id und bestätigt mit dem Status \enquote{Pending}, dass die Revocation lokal gestaged ist. Die Publishing-Phase (Listing~A-\ref{lst:Jupyter-Notebook-Cell-21-output}) führt die Ledger-Transaktion aus (Typ 114 REVOC\_REG\_ENTRY) mit Accumulator-Updates und revokierten Credential-IDs.

Phase~3 validiert das Revocation-Enforcement. Das Holder-Wallet zeigt nach Revocation \enquote{Revoked Status: True} (Listing~A-\ref{lst:Jupyter-Notebook-Cell-14-output-revocation}). Der Holder wählt das revokierte Credential aus, versucht einen Non-Revocation-Proof zu generieren, scheitert jedoch, da der Accumulator das Credential als revoked markiert (Listing~A-\ref{lst:Jupyter-Notebook-Cell-15-output-revocation}, Listing~A-\ref{lst:Jupyter-Notebook-Cell-16-output-revocation}, Listing~A-\ref{lst:Jupyter-Notebook-Cell-17-output-revocation}). Die finale Verifier-Entscheidung (Listing~A-\ref{lst:Jupyter-Notebook-Cell-18-output-revocation}) zeigt \enquote{Verified: false} und \enquote{ZUGANG VERWEIGERT}, da trotz zeitlicher Gültigkeit und erfülltem ZKP-Predicate die Revocation-Prüfung dominiert.

\subsubsection{Credential Deletion}

Die funktionale Anforderung FR6 fordert, dass Holder Credentials lokal aus ihrem Wallet entfernen können, wobei diese Operation nur die lokale Datenhaltung betrifft und vom Ledger-basierten Revocation-Mechanismus zu unterscheiden ist.

Phase~1 implementiert das Pre-Deletion Inventory. Der Abruf aller im Holder-Wallet gespeicherten Credentials (Listing~A-\ref{lst:Jupyter-Notebook-Cell-22-output}) zeigt ein Credential mit \enquote{Revoked: True}. Dieses wurde zuvor via Ledger-Revocation ungültig erklärt, persistiert jedoch weiterhin im lokalen Wallet. Die referent-Identifier werden für die nachfolgende Deletion-Phase erfasst.

Phase~2 realisiert die Credential Deletion durch iterative Entfernung aller erfassten Credentials (Listing~A-\ref{lst:Jupyter-Notebook-Cell-22-output}). Für jeden credential\_id wird via DELETE die lokale Wallet-Entfernung ausgeführt, mit erfolgreicher Deletion bestätigt: \enquote{Gelöscht: 1/1}. Diese Phase demonstriert die Holder-Autonomie über lokale Wallet-Daten ohne Issuer-Interaktion oder Ledger-Transaktion.

Phase~3 validiert die Deletion-Enforcement. Ein erneuter Abruf bestätigt das leere Wallet (Listing~A-\ref{lst:Jupyter-Notebook-Cell-23-output}). Lokale Deletion entfernt das Credential aus Holder-Verfügungsgewalt, jedoch bleibt die Ledger-basierte Revocation-Historie intakt, womit KRITIS-konforme Audit-Trails mit Privacy-wahrenden Holder-Rechten vereinbart werden. Diese Differenzierung ist kritisch für das SSI-Sicherheitsmodell. 

\subsection{Validierung der KRITIS-Compliance-Anforderungen}
\label{sec:Validierung der KRITIS-Compliance-Anforderungen}

\subsubsection{Einhaltung spezifischer Parameter-Sets für ML-DSA}

Die Compliance-Anforderung zur Einhaltung BSI-konformer ML-DSA Parameter-Sets (NIST Security Strength Category 3 oder 5) wird durch strategische Verwendung der zwei Sicherheitsstufen ML-DSA-65 (Category 3) für operationale Signaturen sowie ML-DSA-87 (Category 5) für die Root \ac{CA} erfüllt. Das finale Artefakt implementiert ML-DSA in drei Schichten. In der ersten Schicht werden TLS~1.3 Server-Zertifikate für alle fünf nginx Sidecar-Proxies (Issuer/Holder/Verifier, von-network Webserver, Tails Server) mittels ML-DSA-65 signiert (Listing~A-\ref{lst:docker-compose.yml-DLT-Infrastruktur}, Listing~A-\ref{lst:docker-compose.yml-Revocation-Registry}, Listing~A-\ref{lst:docker-compose.yml-SSI-Agenten}), während die Root \ac{CA} mit ML-DSA-87 geschützt ist (Listing~A-\ref{lst:Zertifikatserstellungsworkflow}). In der zweiten Schicht werden die did:peer:4 Signing Keys mit ML-DSA-65 generiert (Listing~A-\ref{lst:key_types.py}). In der dritten Schicht nutzt DIDComm~v1 Authcrypt Message-Signierung ML-DSA-65 via LibOQS (Listing~A-\ref{lst:liboqs_wrapper.py}) für Sender-Authentifizierung.

Die operationale Integration wird durch \autoref{fig:Successful-Validation-Issuer-TLS1.3} demonstriert, welche die TLS~1.3 Verbindung mit ML-DSA-65 signiertem Server-Zertifikat validiert, sowie durch die Wallet-Übersicht (Listing~A-\ref{lst:Jupyter-Notebook-Cell-12-output}), in welcher alle drei SSI-Agenten key\_type ML-DSA-65 für did:peer:4 DIDs nutzen.

\subsubsection{Einhaltung spezifischer Parameter-Sets für ML-KEM}

Diese Anforderung wird durch systemweite Implementierung von ML-KEM-768 (Category 3) erfüllt. Das finale Artefakt implementiert ML-KEM-768 in zwei Schichten. In der ersten Schicht nutzt TLS~1.3 Key Exchange für alle fünf nginx-\ac{PQC}-Sidecar-Proxies ML-KEM-768 konfiguriert via \enquote{DEFAULT\_GROUPS=X25519MLKEM768mlkem768x25519} in den Docker-Infrastruktur-Definitionen (Listing~A-\ref{lst:docker-compose.yml-DLT-Infrastruktur}, Listing~A-\ref{lst:docker-compose.yml-Revocation-Registry}, Listing~A-\ref{lst:docker-compose.yml-SSI-Agenten}) sowie via ssl\_ecdh\_curve X25519MLKEM768 in den nginx-Konfigurationen (Listing~A-\ref{lst:nginx_holder.conf}). In der zweiten Schicht wird did:peer:4 Key Agreement für Agent-to-Agent Verschlüsselung mit ML-KEM-768 realisiert (Listing~A-\ref{lst:key_types.py}), womit \gls{DIDComm}-Nachrichten Post-Quantum-resistent verschlüsselt werden.

Die operationale Integration wird durch \autoref{fig:Successful-Validation-Issuer-TLS1.3} demonstriert, welche die TLS~1.3 Verbindung mittels der \enquote{Negotiated TLS1.3 group: X25519MLKEM768} validiert, sowie durch die Wallet-Übersicht (Listing~A-\ref{lst:Jupyter-Notebook-Cell-12-output}), in welcher alle drei SSI-Agenten key\_agreement\_algorithm ML-KEM-768 für did:peer:4 DIDs nutzen.

\subsubsection{Implementierung hybrider Schlüsseleinigung}

Die BSI-Anforderung zur hybriden Schlüsseleinigung (Kombination klassisches Verfahren mit PQC-KEM) wird durch den X25519+ML-KEM-768-Hybrid-Modus erfüllt. Das finale Artefakt implementiert hybride Schlüsseleinigung systemweit via \enquote{DEFAULT\_GROUPS=X25519MLKEM768:mlkem768:x25519} in allen Docker-Infrastruktur-Definitionen (Listing~A-\ref{lst:docker-compose.yml-DLT-Infrastruktur}, Listing~A-\ref{lst:docker-compose.yml-Revocation-Registry}, Listing~A-\ref{lst:docker-compose.yml-SSI-Agenten}), wobei die Priorisierung X25519MLKEM768 als primären Hybrid-Modus sicherstellt. Die TLS~1.3 Verbindungen aller fünf nginx-\ac{PQC}-Sidecar-Proxies kombinieren X25519 mit ML-KEM-768 (Listing~A-\ref{lst:nginx_holder.conf}). Zusätzlich implementiert did:peer:4 hybride Key Agreement zwischen X25519- und ML-KEM-768-Keys aus DID Documents für \gls{DIDComm} Message Encryption (Listing~A-\ref{lst:key_types.py}). Die Fallback-Strategie mlkem768:x25519 gewährleistet Interoperabilität mit Peers ohne Hybrid-Unterstützung, wobei reine PQC-Verschlüsselung via ML-KEM-768 Vorrang vor klassischem X25519 hat. Diese Architektur entspricht \textcite[Kap. 2.2, 2.4]{bsi_BSITR021021KryptographischeVerfahrenEmpfehlungenundSchluessellaengenVersion202501_2025} zur Absicherung gegen kryptanalytische Angriffe sowohl im klassischen als auch im Quantum-Computing-Bereich.

\subsubsection{Bevorzugte Verwendung von TLS 1.3}

Die BSI-Empfehlung zur vorrangigen Verwendung von TLS~1.3 wird durch systemweite TLS~1.3-Enforcement erfüllt. Das finale Artefakt erzwingt TLS~1.3 in allen fünf nginx-\ac{PQC}-Sidecar-Proxies via \enquote{ssl\_protocols TLSv1.3;} in den Konfigurationsdateien (Listing~A-\ref{lst:nginx_holder.conf}). \autoref{fig:Summative_Evaluation_TLS1.2_Error} demonstriert das Fehlschlagen des TLS~1.2 Verbindungsversuchs zum Issuer-Agenten.

\begin{figure}[H]
    \centering
    \includegraphics[width=\paperwidth, height=\paperheight, keepaspectratio, angle=90]{summative_evaluation_TLS1.2_error.png}
    \caption{TLS 1.3 Enforcement blockiert Legacy-Verbindungsversuch}
    \begin{flushleft}
    \textit{Anmerkung.} Eigene Darstellung.
    \end{flushleft}
    \label{fig:Summative_Evaluation_TLS1.2_Error}
\end{figure}

\subsubsection{Protokollierung Sicherheitsrelevanter Ereignisse}

Das finale Artefakt implementiert Protokollierung auf drei integrierten Ebenen zur Gewährleistung eines unveränderlichen Audit-Trails. ACA-Py Agent-Level Logging protokolliert Authentifizierungsversuche, Zustandsübergänge und Fehlerzustände via --log-level info (Listing~A-\ref{lst:docker-compose.yml-SSI-Agenten}), wobei kryptographische Events wie ML-DSA-65 Signature Verification und \gls{DIDComm}-Decryption dokumentiert werden (Listing~A-\ref{lst:issuer-acapy-agent-logs}). nginx Access und Error Logs auf allen fünf Sidecar-Proxies erfassen TLS-Handshakes und HTTP-Requests (Listing~A-\ref{lst:docker-compose.yml-DLT-Infrastruktur}, Listing~A-\ref{lst:docker-compose.yml-Revocation-Registry}), wobei Request-Body-Buffering für PQC-Schlüsselmaterialien protokolliert wird (Listing~A-\ref{lst:issuer-nginx-logs}). Die von-network Ledger Transaction Logs erfassen alle Blockchain-Operationen (NYM-, SCHEMA-, CRED\_DEF-, REVOC\_REG\_ENTRY-Transaktionen) mit Zeitstempeln und Sequence Numbers, womit ein kryptographisch verifizierter, unveränderlicher Audit-Trail für KRITIS-Compliance-Anforderungen realisiert wird (Listing~A-\ref{lst:Jupyter-Notebook-Cell-4-output}, Listing~A-\ref{lst:Jupyter-Notebook-Cell-21-output}).

\subsubsection{Logische Netzsegmentierung}

Das finale Artefakt implementiert strikte Netzwerk-Segmentierung mittels dedizierter Docker Networks zur Isolation kritischer Infrastruktur-Komponenten. Die SSI-Agenten nutzen isolierte Networks (hope-issuer, hope-holder, hope-verifier) pro Agent, wobei nur zugehörige Sidecar-Proxies Zugriff haben (Listing~A-\ref{lst:docker-compose.yml-SSI-Agenten}). Das Shared Network \enquote{von\_sidecarproxy} verbindet ausschließlich die nginx-\ac{PQC}-Sidecar-Proxies untereinander für Agent-to-Agent Kommunikation, während interne Agent-Container isoliert bleiben. Die Blockchain-Nodes operieren im dedizierten \enquote{von-network} mit separatem sidecarproxy Network für Webserver-Zugriff (Listing~A-\ref{lst:docker-compose.yml-DLT-Infrastruktur}), und der Tails Server nutzt ein isoliertes tails-server Network mit kontrolliertem Zugang via \enquote{von\_sidecarproxy} (Listing~A-\ref{lst:docker-compose.yml-Revocation-Registry}). Diese mehrstufige Segmentierung, visualisiert in \autoref{fig:Docker-Compose-Übersicht-Iteration-1} und \autoref{fig:Darstellung-Network-Isolation}, realisiert strenge Netzwerk-Isolation gemäß \textcite[Control A.8.22]{iso/iec_ISOIEC270012022InformationsecuritycybersecurityprivacyprotectionInformationsecuritymanagement_2022}.

\subsubsection{Datenschutz durch Technikgestaltung (Privacy by Design)}

Die \ac{DSGVO}-Anforderung zu Privacy by Design \parencite[Art. 25]{daseuropaeischeparlamentundderratdereuropaeischenunion_VerordnungEU2016679EuropaeischenParlamentsundRatesvom27April2016_2016} wird durch architektonische Trennung von öffentlichen Identifikatoren und personenbezogenen Daten erfüllt. Das finale Artefakt realisiert eine konsequente Off-Chain-Architektur, in der personenbezogene Daten (Name, Organisation, Sicherheitsfreigabe) ausschließlich in verschlüsselten Verifiable Credentials lokal im Holder-Wallet persistiert werden (Listing~A-\ref{lst:Jupyter-Notebook-Cell-14-output}), während Ledger-Transaktionen nur kryptographische Identifikatoren (Schema-IDs, Credential-Definition-IDs, Revocation-Registry-IDs) und Public Keys enthalten (Listing~A-\ref{lst:Jupyter-Notebook-Cell-4-output}, Listing~A-\ref{lst:Jupyter-Notebook-Cell-21-output}). \ac{ZKP}s ermöglichen selektive Offenlegung. Der Verifier erhält nur angeforderte Attribute, während sensible Daten geschützt bleiben, und Predicate-basierte Proofs (security\_clearance\_level >= 2) erfolgen ohne Offenlegung exakter Werte (Listing~A-\ref{lst:Jupyter-Notebook-Cell-18-output-revocation}). Diese Architektur stellt Privacy by Default sicher, da personenbezogene Daten dezentral beim Holder verbleiben und nur kryptographisch verifizierbare Proofs ausgetauscht werden.

\subsubsection{Grundsatz der Datenminimierung}

Das finale Artefakt addressiert Datenminimierung durch drei komplementäre Mechanismen. Pairwise did:peer:4 DIDs eliminieren globale Identifikatoren. Für jede Agent-to-Agent Connection wird eine dedizierte DID generiert (Listing~A-\ref{lst:Jupyter-Notebook-Cell-12-output}), wodurch Transaktionskorrelation über verschiedene Verifier unterbunden wird und ein kompromittierter Verifier keine Aktivitäten des Holders bei anderen Verifiern nachverfolgen kann. Selective Disclosure in Proof Presentations offenbart ausschließlich angeforderte Attribute (cert\_type, facility\_type, epoch\_valid\_from/until, role), während Identitätsdaten (first\_name, name, organisation) unrevealed bleiben (Listing~A-\ref{lst:Jupyter-Notebook-Cell-18-output-revocation}), wodurch nur zweckgebundene Minimaldaten übermittelt werden. Predicate-basierte \ac{ZKP}s reduzieren Datenoffenlegung weiter. Der Holder beweist kryptographisch security\_clearance\_level >= 2 ohne Preisgabe der exakten Stufe (Listing~A-\ref{lst:Jupyter-Notebook-Cell-18-output-revocation}). Diese mehrstufige Datenminimierung verhindert Profilbildung und Datensammlung, womit \ac{DSGVO}-konforme Zweckbindung \parencite[Art. 5]{daseuropaeischeparlamentundderratdereuropaeischenunion_VerordnungEU2016679EuropaeischenParlamentsundRatesvom27April2016_2016} technisch durchgesetzt wird.

\subsubsection{Recht auf Löschung}

Die \ac{DSGVO}-Anforderung zum Recht auf Löschung \parencite[Art. 17]{daseuropaeischeparlamentundderratdereuropaeischenunion_VerordnungEU2016679EuropaeischenParlamentsundRatesvom27April2016_2016} wird durch strikte Trennung von Ledger-Identifikatoren und Wallet-Daten erfüllt. Das finale Artefakt realisiert vollständige Löschbarkeit personenbezogener Daten durch lokale Credential-Deletion via DELETE /credential/{<credential\_id>}, wobei der sich im Holder-Wallet befindliche Credential (<credential\_id>) gelöscht wird und damit alle personenbezogenen Attribute (Name, Organisation, Sicherheitsfreigabe) irreversibel verloren sind (Listing~A-\ref{lst:Jupyter-Notebook-Cell-22}). Crypto-Shredding durch Wallet-Destruction gewährleistet kryptographische Unlesbarkeit aller Credential-Daten. Die Vernichtung des Wallet-Keys führt zur Unmöglichkeit der Entschlüsselung, selbst wenn Backups existieren (Listing~A-\ref{lst:Jupyter-Notebook-Cell-22-output}). Während Blockchain-Transaktionen (Schema-IDs, Cred-Def-IDs, Revocation-Entries) unveränderlich auf dem Ledger verbleiben, enthalten diese per Design keine personenbezogenen Daten, sondern nur kryptographische Identifier (Listing~A-\ref{lst:Jupyter-Notebook-Cell-22-output}). Diese Architektur gewährleistet vollständige Löschung personenbezogener Daten bei gleichzeitiger Audit-Trail-Integrität.

\subsection{Validierung der Kryptoagilität}
\label{sec:Validierung der Kryptoagilität}

\subsubsection{Transportlayer}

TLS 1.3 realisiert Kryptoagilität durch orthogonale Aushandlung von Cipher Suite, Schlüsselaustauschverfahren und Signaturalgorithmen \parencite[S. 26]{rescorla_TransportLayerSecurityTLSProtocolVersion13_2018}, wodurch jeder Mechanismus unabhängig modifiziert werden kann. Die supported\_groups-Erweiterung ermöglicht es Endpunkten, Schlüsselaustauschverfahren unabhängig vom symmetrischen Verschlüsselungsverfahren auszuhandeln \parencite[S. 47]{rescorla_TransportLayerSecurityTLSProtocolVersion13_2018}. Diese Architektur adressiert die Kryptoagilitätseigenschaften Extensibility und Removability nach \textcite[S. 102]{mehrez_CryptoAgilityProperties_2018}.

Die Implementierung nutzt hierfür eine konfigurationsbasierte Algorithm-Fallback-Chain via \enquote{DEFAULT\_GROUPS=X25519MLKEM768:mlkem768:x25519:mlkem1024} (Listing~A-\ref{lst:Dockerfile-Sidecar-Proxy-nginx}), die primär hybride Verfahren nutzt und automatisch auf rein klassische Verfahren (x25519) bei Inkompatibilität zurückfällt. Dies erfüllt die Fungibility-Anforderung nach \textcite[S. 102]{mehrez_CryptoAgilityProperties_2018} und ermöglicht Algorithmenauswahl in Echtzeit basierend auf Sicherheitsfunktion \parencite[S. 19]{cyberresilienceworkshopseriescommittee_CryptographicAgilityInteroperabilityProceedingsWorkshop_2017}. \autoref{fig:Summative_Evaluation_TLS1.3_Kryptoagilität} demonstriert den kryptoagilen Fallback-Prozess.

\begin{figure}[H]
    \centering
    \includegraphics[width=\paperwidth, height=\paperheight, keepaspectratio, angle=90]{summative_evaluation_TLS1.3_kryptoagilität.png}
    \caption{TLS 1.3 Kryptoagiler Fallback von X25519ML-KEM-768 zu X25519}
    \begin{flushleft}
    \textit{Anmerkung.} Eigene Darstellung.
    \end{flushleft}
    \label{fig:Summative_Evaluation_TLS1.3_Kryptoagilität}
\end{figure}

\subsubsection{Applikationslayer}

Die Applikationsebene nutzt die Plugin-Architektur von ACA-Py zur Algorithmenauswahl ohne Modifikation des Kerncode, entsprechend dem Open-Closed-Prinzip nach \textcite[S. 99]{martin_AgileSoftwareDevelopmentprinciplespatternspractices_2003}. Das Plugin implementiert einen metadatengesteuerten Ansatz. Via Parameter \enquote{metadata: {key\_type: ed25519}} kann der Schlüsseltyp explizit spezifiziert werden (Listing~A-\ref{lst:Jupyter-Notebook-Cell-9-Demonstration-Kryptoagilität-ed25519}). Der OutOfBandManager evaluiert in create\_did\_peer\_4\_conditional\_pqc (Listing~A-\ref{lst:base_manager_patch.py}) den key\_type-Parameter. Wird \enquote{ed25519} erkannt, delegiert das Plugin zur ursprünglichen ACA-Py-Implementierung für vollständigen Fallback auf klassische Kryptografie, fehlt die Spezifikation, aktiviert das System standardmäßig ML-DSA-65 und ML-KEM-768.

Die erfolgreiche Validierung zeigt Listing~A-\ref{lst:Jupyter-Notebook-Cell-9-Demonstration-Kryptoagilität-ed25519-output}. Eine ED25519-basierte Verbindung etabliert sich mit Status \enquote{active}, was korrekte DID Exchange-Durchführung mit klassischen Algorithmen bestätigt. Listing~A-\ref{lst:Jupyter-Notebook-Cell-11-Demonstration-Kryptoagilität-ed25519-output} verifiziert persistierte Kryptografie. Wallet-DIDs zeigen konsistent \enquote{key\_type: ed25519}, wobei Abwesenheit von PQC-Metadaten (pqc\_enabled, signature\_algorithm, kem\_verkey) bestätigt, dass das Plugin keine Eingriffe im ED25519-Workflow vornahm.